// !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!!
import type * as t from "./types";
export interface TemplateBuilder {
  (body: t.Node[]): t.Template;
  from(params: { body: t.Node[] }): t.Template;
}
export interface OutputBuilder {
  (nodes: t.Expr[]): t.Output;
  from(params: { nodes: t.Expr[] }): t.Output;
}
export interface ExtendsBuilder {
  (template: t.Expr): t.Extends;
  from(params: { template: t.Expr }): t.Extends;
}
export interface ForBuilder {
  (
    target: t.Node,
    iter: t.Node,
    body: t.Node[],
    else_: t.Node[],
    test?: t.Node | null,
    recursive?: boolean
  ): t.For;
  from(params: {
    body: t.Node[];
    else_: t.Node[];
    iter: t.Node;
    recursive?: boolean;
    target: t.Node;
    test?: t.Node | null;
  }): t.For;
}
export interface IfBuilder {
  (test: t.Node, body: t.Node[], elif: t.If[], else_: t.Node[]): t.If;
  from(params: {
    body: t.Node[];
    elif: t.If[];
    else_: t.Node[];
    test: t.Node;
  }): t.If;
}
export interface NameBuilder {
  (name: string, ctx: string): t.Name;
  from(params: { ctx: string; name: string }): t.Name;
}
export interface MacroBuilder {
  (name: string, args: t.Name[], defaults: t.Expr[], body: t.Node[]): t.Macro;
  from(params: {
    args: t.Name[];
    body: t.Node[];
    defaults: t.Expr[];
    name: string;
  }): t.Macro;
}
export interface KeywordBuilder {
  (key: string, value: t.Expr): t.Keyword;
  from(params: { key: string; value: t.Expr }): t.Keyword;
}
export interface CallBuilder {
  (
    node: t.Expr,
    args: t.Expr[],
    kwargs: t.Keyword[],
    dynArgs?: t.Expr | null,
    dynKwargs?: t.Expr | null
  ): t.Call;
  from(params: {
    args: t.Expr[];
    dynArgs?: t.Expr | null;
    dynKwargs?: t.Expr | null;
    kwargs: t.Keyword[];
    node: t.Expr;
  }): t.Call;
}
export interface CallBlockBuilder {
  (
    call: t.Call,
    args: t.Name[],
    defaults: t.Expr[],
    body: t.Node[]
  ): t.CallBlock;
  from(params: {
    args: t.Name[];
    body: t.Node[];
    call: t.Call;
    defaults: t.Expr[];
  }): t.CallBlock;
}
export interface PairBuilder {
  (key: t.Expr, value: t.Expr): t.Pair;
  from(params: { key: t.Expr; value: t.Expr }): t.Pair;
}
export interface FilterBuilder {
  (
    node: t.Expr | null,
    name: string,
    args: t.Expr[],
    kwargs: t.Pair[],
    dynArgs?: t.Expr | null,
    dynKwargs?: t.Expr | null
  ): t.Filter;
  from(params: {
    args: t.Expr[];
    dynArgs?: t.Expr | null;
    dynKwargs?: t.Expr | null;
    kwargs: t.Pair[];
    name: string;
    node: t.Expr | null;
  }): t.Filter;
}
export interface TestBuilder {
  (
    node: t.Expr,
    name: string,
    args: t.Expr[],
    kwargs: t.Pair[],
    dynArgs?: t.Expr | null,
    dynKwargs?: t.Expr | null
  ): t.Test;
  from(params: {
    args: t.Expr[];
    dynArgs?: t.Expr | null;
    dynKwargs?: t.Expr | null;
    kwargs: t.Pair[];
    name: string;
    node: t.Expr;
  }): t.Test;
}
export interface FilterBlockBuilder {
  (body: t.Node[], filter: t.Filter): t.FilterBlock;
  from(params: { body: t.Node[]; filter: t.Filter }): t.FilterBlock;
}
export interface WithBuilder {
  (targets: t.Expr[], values: t.Expr[], body: t.Node[]): t.With;
  from(params: { body: t.Node[]; targets: t.Expr[]; values: t.Expr[] }): t.With;
}
export interface BlockBuilder {
  (name: string, body: t.Node[], scoped: boolean, required: boolean): t.Block;
  from(params: {
    body: t.Node[];
    name: string;
    required: boolean;
    scoped: boolean;
  }): t.Block;
}
export interface IncludeBuilder {
  (template: t.Expr, withContext: boolean, ignoreMissing: boolean): t.Include;
  from(params: {
    ignoreMissing: boolean;
    template: t.Expr;
    withContext: boolean;
  }): t.Include;
}
export interface FromImportBuilder {
  (
    template: t.Expr,
    names: (string | string[])[],
    withContext: boolean
  ): t.FromImport;
  from(params: {
    names: (string | string[])[];
    template: t.Expr;
    withContext: boolean;
  }): t.FromImport;
}
export interface ExprStmtBuilder {
  (node: t.Node): t.ExprStmt;
  from(params: { node: t.Node }): t.ExprStmt;
}
export interface AssignBuilder {
  (target: t.Expr, node: t.Node): t.Assign;
  from(params: { node: t.Node; target: t.Expr }): t.Assign;
}
export interface AssignBlockBuilder {
  (
    target: t.Expr,
    filter: (t.Filter | null) | undefined,
    body: t.Node[]
  ): t.AssignBlock;
  from(params: {
    body: t.Node[];
    filter?: t.Filter | null;
    target: t.Expr;
  }): t.AssignBlock;
}
export interface NSRefBuilder {
  (name: string, attr: string): t.NSRef;
  from(params: { attr: string; name: string }): t.NSRef;
}
export interface ConstBuilder {
  (value: any): t.Const;
  from(params: { value: any }): t.Const;
}
export interface TemplateDataBuilder {
  (data: string): t.TemplateData;
  from(params: { data: string }): t.TemplateData;
}
export interface TupleBuilder {
  (items: t.Expr[], ctx: string): t.Tuple;
  from(params: { ctx: string; items: t.Expr[] }): t.Tuple;
}
export interface ListBuilder {
  (items: t.Expr[]): t.List;
  from(params: { items: t.Expr[] }): t.List;
}
export interface DictBuilder {
  (items: t.Pair[]): t.Dict;
  from(params: { items: t.Pair[] }): t.Dict;
}
export interface CondExprBuilder {
  (test: t.Expr, expr1: t.Expr, expr2?: t.Expr | null): t.CondExpr;
  from(params: {
    expr1: t.Expr;
    expr2?: t.Expr | null;
    test: t.Expr;
  }): t.CondExpr;
}
export interface GetitemBuilder {
  (node: t.Expr, arg: t.Expr, ctx: string): t.Getitem;
  from(params: { arg: t.Expr; ctx: string; node: t.Expr }): t.Getitem;
}
export interface GetattrBuilder {
  (node: t.Expr, attr: string, ctx: string): t.Getattr;
  from(params: { attr: string; ctx: string; node: t.Expr }): t.Getattr;
}
export interface SliceBuilder {
  (start?: t.Expr | null, stop?: t.Expr | null, step?: t.Expr | null): t.Slice;
  from(params: {
    start?: t.Expr | null;
    step?: t.Expr | null;
    stop?: t.Expr | null;
  }): t.Slice;
}
export interface ConcatBuilder {
  (nodes: t.Expr[]): t.Concat;
  from(params: { nodes: t.Expr[] }): t.Concat;
}
export interface CompareBuilder {
  (expr: t.Expr, ops: t.Operand[]): t.Compare;
  from(params: { expr: t.Expr; ops: t.Operand[] }): t.Compare;
}
export interface OperandBuilder {
  (op: string, expr: t.Expr): t.Operand;
  from(params: { expr: t.Expr; op: string }): t.Operand;
}
export interface MulBuilder {
  (left: t.Expr, right: t.Expr, operator: "*"): t.Mul;
  from(params: { left: t.Expr; operator: "*"; right: t.Expr }): t.Mul;
}
export interface DivBuilder {
  (left: t.Expr, right: t.Expr, operator: "/"): t.Div;
  from(params: { left: t.Expr; operator: "/"; right: t.Expr }): t.Div;
}
export interface FloorDivBuilder {
  (left: t.Expr, right: t.Expr, operator: "//"): t.FloorDiv;
  from(params: { left: t.Expr; operator: "//"; right: t.Expr }): t.FloorDiv;
}
export interface AddBuilder {
  (left: t.Expr, right: t.Expr, operator: "+"): t.Add;
  from(params: { left: t.Expr; operator: "+"; right: t.Expr }): t.Add;
}
export interface SubBuilder {
  (left: t.Expr, right: t.Expr, operator: "-"): t.Sub;
  from(params: { left: t.Expr; operator: "-"; right: t.Expr }): t.Sub;
}
export interface ModBuilder {
  (left: t.Expr, right: t.Expr, operator: "%"): t.Mod;
  from(params: { left: t.Expr; operator: "%"; right: t.Expr }): t.Mod;
}
export interface PowBuilder {
  (left: t.Expr, right: t.Expr, operator: "**"): t.Pow;
  from(params: { left: t.Expr; operator: "**"; right: t.Expr }): t.Pow;
}
export interface AndBuilder {
  (left: t.Expr, right: t.Expr, operator: "and"): t.And;
  from(params: { left: t.Expr; operator: "and"; right: t.Expr }): t.And;
}
export interface OrBuilder {
  (left: t.Expr, right: t.Expr, operator: "or"): t.Or;
  from(params: { left: t.Expr; operator: "or"; right: t.Expr }): t.Or;
}
export interface NotBuilder {
  (operator: "not"): t.Not;
  from(params: { operator: "not" }): t.Not;
}
export interface NegBuilder {
  (operator: "-"): t.Neg;
  from(params: { operator: "-" }): t.Neg;
}
export interface PosBuilder {
  (operator: "+"): t.Pos;
  from(params: { operator: "+" }): t.Pos;
}
export interface EnvironmentAttributeBuilder {
  (name: string): t.EnvironmentAttribute;
  from(params: { name: string }): t.EnvironmentAttribute;
}
export interface ExtensionAttributeBuilder {
  (identifier: string, name: string): t.ExtensionAttribute;
  from(params: { identifier: string; name: string }): t.ExtensionAttribute;
}
export interface ImportedNameBuilder {
  (importname: string): t.ImportedName;
  from(params: { importname: string }): t.ImportedName;
}
export interface InternalNameBuilder {
  (name: string): t.InternalName;
  from(params: { name: string }): t.InternalName;
}
export interface MarkSafeBuilder {
  (expr: t.Expr): t.MarkSafe;
  from(params: { expr: t.Expr }): t.MarkSafe;
}
export interface MarkSafeIfAutoescapeBuilder {
  (expr: t.Expr): t.MarkSafeIfAutoescape;
  from(params: { expr: t.Expr }): t.MarkSafeIfAutoescape;
}
export interface ContextReferenceBuilder {
  (): t.ContextReference;
  from(params: {}): t.ContextReference;
}
export interface DerivedContextReferenceBuilder {
  (): t.DerivedContextReference;
  from(params: {}): t.DerivedContextReference;
}
export interface ContinueBuilder {
  (): t.Continue;
  from(params: {}): t.Continue;
}
export interface BreakBuilder {
  (): t.Break;
  from(params: {}): t.Break;
}
export interface ScopeBuilder {
  (body: t.Node[]): t.Scope;
  from(params: { body: t.Node[] }): t.Scope;
}
export interface OverlayScopeBuilder {
  (context: t.Expr, body: t.Node[]): t.OverlayScope;
  from(params: { body: t.Node[]; context: t.Expr }): t.OverlayScope;
}
export interface EvalContextModifierBuilder {
  (options: t.Keyword[]): t.EvalContextModifier;
  from(params: { options: t.Keyword[] }): t.EvalContextModifier;
}
export interface ScopedEvalContextModifierBuilder {
  (options: t.Keyword[], body: t.Node[]): t.ScopedEvalContextModifier;
  from(params: {
    body: t.Node[];
    options: t.Keyword[];
  }): t.ScopedEvalContextModifier;
}
export interface builders {
  template: TemplateBuilder;
  output: OutputBuilder;
  extends: ExtendsBuilder;
  for: ForBuilder;
  if: IfBuilder;
  name: NameBuilder;
  macro: MacroBuilder;
  keyword: KeywordBuilder;
  call: CallBuilder;
  callBlock: CallBlockBuilder;
  pair: PairBuilder;
  filter: FilterBuilder;
  test: TestBuilder;
  filterBlock: FilterBlockBuilder;
  with: WithBuilder;
  block: BlockBuilder;
  include: IncludeBuilder;
  fromImport: FromImportBuilder;
  exprStmt: ExprStmtBuilder;
  assign: AssignBuilder;
  assignBlock: AssignBlockBuilder;
  nsRef: NSRefBuilder;
  const: ConstBuilder;
  templateData: TemplateDataBuilder;
  tuple: TupleBuilder;
  list: ListBuilder;
  dict: DictBuilder;
  condExpr: CondExprBuilder;
  getitem: GetitemBuilder;
  getattr: GetattrBuilder;
  slice: SliceBuilder;
  concat: ConcatBuilder;
  compare: CompareBuilder;
  operand: OperandBuilder;
  mul: MulBuilder;
  div: DivBuilder;
  floorDiv: FloorDivBuilder;
  add: AddBuilder;
  sub: SubBuilder;
  mod: ModBuilder;
  pow: PowBuilder;
  and: AndBuilder;
  or: OrBuilder;
  not: NotBuilder;
  neg: NegBuilder;
  pos: PosBuilder;
  environmentAttribute: EnvironmentAttributeBuilder;
  extensionAttribute: ExtensionAttributeBuilder;
  importedName: ImportedNameBuilder;
  internalName: InternalNameBuilder;
  markSafe: MarkSafeBuilder;
  markSafeIfAutoescape: MarkSafeIfAutoescapeBuilder;
  contextReference: ContextReferenceBuilder;
  derivedContextReference: DerivedContextReferenceBuilder;
  continue: ContinueBuilder;
  break: BreakBuilder;
  scope: ScopeBuilder;
  overlayScope: OverlayScopeBuilder;
  evalContextModifier: EvalContextModifierBuilder;
  scopedEvalContextModifier: ScopedEvalContextModifierBuilder;
  [builderName: string]: any;
}
