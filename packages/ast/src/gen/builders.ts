// !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!!
import type * as types from "./types";
export interface TemplateBuilder {
  (body: types.Node[]): types.Template;
  from(params: {
    body: types.Node[];
    loc?: types.SourceLocation | null;
  }): types.Template;
}
export interface OutputBuilder {
  (nodes: types.Expr[]): types.Output;
  from(params: {
    loc?: types.SourceLocation | null;
    nodes: types.Expr[];
  }): types.Output;
}
export interface ExtendsBuilder {
  (template: types.Expr): types.Extends;
  from(params: {
    loc?: types.SourceLocation | null;
    template: types.Expr;
  }): types.Extends;
}
export interface ForBuilder {
  (
    target: types.Node,
    iter: types.Node,
    body: types.Node[],
    else_: types.Node[],
    test?: types.Node | null,
    recursive?: boolean
  ): types.For;
  from(params: {
    body: types.Node[];
    else_: types.Node[];
    iter: types.Node;
    loc?: types.SourceLocation | null;
    recursive?: boolean;
    target: types.Node;
    test?: types.Node | null;
  }): types.For;
}
export interface AsyncEachBuilder {
  (
    target: types.Node,
    iter: types.Node,
    body: types.Node[],
    else_: types.Node[],
    test?: types.Node | null,
    recursive?: boolean
  ): types.AsyncEach;
  from(params: {
    body: types.Node[];
    else_: types.Node[];
    iter: types.Node;
    loc?: types.SourceLocation | null;
    recursive?: boolean;
    target: types.Node;
    test?: types.Node | null;
  }): types.AsyncEach;
}
export interface AsyncAllBuilder {
  (
    target: types.Node,
    iter: types.Node,
    body: types.Node[],
    else_: types.Node[],
    test?: types.Node | null,
    recursive?: boolean
  ): types.AsyncAll;
  from(params: {
    body: types.Node[];
    else_: types.Node[];
    iter: types.Node;
    loc?: types.SourceLocation | null;
    recursive?: boolean;
    target: types.Node;
    test?: types.Node | null;
  }): types.AsyncAll;
}
export interface IfBuilder {
  (
    test: types.Node,
    body: types.Node[],
    elif: types.If[],
    else_: types.Node[]
  ): types.If;
  from(params: {
    body: types.Node[];
    elif: types.If[];
    else_: types.Node[];
    loc?: types.SourceLocation | null;
    test: types.Node;
  }): types.If;
}
export interface NameBuilder {
  (name: string, ctx: string): types.Name;
  from(params: {
    ctx: string;
    loc?: types.SourceLocation | null;
    name: string;
  }): types.Name;
}
export interface MacroBuilder {
  (
    name: string,
    args: types.Name[],
    defaults: types.Expr[],
    body: types.Node[]
  ): types.Macro;
  from(params: {
    args: types.Name[];
    body: types.Node[];
    defaults: types.Expr[];
    loc?: types.SourceLocation | null;
    name: string;
  }): types.Macro;
}
export interface KeywordBuilder {
  (key: string, value: types.Expr): types.Keyword;
  from(params: {
    key: string;
    loc?: types.SourceLocation | null;
    value: types.Expr;
  }): types.Keyword;
}
export interface CallBuilder {
  (
    node: types.Expr,
    args: types.Expr[],
    kwargs: types.Keyword[],
    dynArgs?: types.Expr | null,
    dynKwargs?: types.Expr | null
  ): types.Call;
  from(params: {
    args: types.Expr[];
    dynArgs?: types.Expr | null;
    dynKwargs?: types.Expr | null;
    kwargs: types.Keyword[];
    loc?: types.SourceLocation | null;
    node: types.Expr;
  }): types.Call;
}
export interface CallBlockBuilder {
  (
    call: types.Call,
    args: types.Name[],
    defaults: types.Expr[],
    body: types.Node[]
  ): types.CallBlock;
  from(params: {
    args: types.Name[];
    body: types.Node[];
    call: types.Call;
    defaults: types.Expr[];
    loc?: types.SourceLocation | null;
  }): types.CallBlock;
}
export interface PairBuilder {
  (key: types.Expr, value: types.Expr): types.Pair;
  from(params: {
    key: types.Expr;
    loc?: types.SourceLocation | null;
    value: types.Expr;
  }): types.Pair;
}
export interface FilterBuilder {
  (
    node: types.Expr | null,
    name: string,
    args: types.Expr[],
    kwargs: types.Pair[],
    dynArgs?: types.Expr | null,
    dynKwargs?: types.Expr | null
  ): types.Filter;
  from(params: {
    args: types.Expr[];
    dynArgs?: types.Expr | null;
    dynKwargs?: types.Expr | null;
    kwargs: types.Pair[];
    loc?: types.SourceLocation | null;
    name: string;
    node: types.Expr | null;
  }): types.Filter;
}
export interface TestBuilder {
  (
    node: types.Expr,
    name: string,
    args: types.Expr[],
    kwargs: types.Pair[],
    dynArgs?: types.Expr | null,
    dynKwargs?: types.Expr | null
  ): types.Test;
  from(params: {
    args: types.Expr[];
    dynArgs?: types.Expr | null;
    dynKwargs?: types.Expr | null;
    kwargs: types.Pair[];
    loc?: types.SourceLocation | null;
    name: string;
    node: types.Expr;
  }): types.Test;
}
export interface FilterBlockBuilder {
  (body: types.Node[], filter: types.Filter): types.FilterBlock;
  from(params: {
    body: types.Node[];
    filter: types.Filter;
    loc?: types.SourceLocation | null;
  }): types.FilterBlock;
}
export interface WithBuilder {
  (targets: types.Expr[], values: types.Expr[], body: types.Node[]): types.With;
  from(params: {
    body: types.Node[];
    loc?: types.SourceLocation | null;
    targets: types.Expr[];
    values: types.Expr[];
  }): types.With;
}
export interface BlockBuilder {
  (
    name: string,
    body: types.Node[],
    scoped: boolean,
    required: boolean
  ): types.Block;
  from(params: {
    body: types.Node[];
    loc?: types.SourceLocation | null;
    name: string;
    required: boolean;
    scoped: boolean;
  }): types.Block;
}
export interface IncludeBuilder {
  (
    template: types.Expr,
    withContext: boolean,
    ignoreMissing: boolean
  ): types.Include;
  from(params: {
    ignoreMissing: boolean;
    loc?: types.SourceLocation | null;
    template: types.Expr;
    withContext: boolean;
  }): types.Include;
}
export interface ImportBuilder {
  (template: types.Expr, target: string, withContext: boolean): types.Import;
  from(params: {
    loc?: types.SourceLocation | null;
    target: string;
    template: types.Expr;
    withContext: boolean;
  }): types.Import;
}
export interface FromImportBuilder {
  (
    template: types.Expr,
    names: (string | string[])[],
    withContext: boolean
  ): types.FromImport;
  from(params: {
    loc?: types.SourceLocation | null;
    names: (string | string[])[];
    template: types.Expr;
    withContext: boolean;
  }): types.FromImport;
}
export interface ExprStmtBuilder {
  (node: types.Node): types.ExprStmt;
  from(params: {
    loc?: types.SourceLocation | null;
    node: types.Node;
  }): types.ExprStmt;
}
export interface AssignBuilder {
  (
    target: types.NSRef | types.Name | types.Tuple,
    node: types.Expr
  ): types.Assign;
  from(params: {
    loc?: types.SourceLocation | null;
    node: types.Expr;
    target: types.NSRef | types.Name | types.Tuple;
  }): types.Assign;
}
export interface NSRefBuilder {
  (name: string, attr: string): types.NSRef;
  from(params: {
    attr: string;
    loc?: types.SourceLocation | null;
    name: string;
  }): types.NSRef;
}
export interface TupleBuilder {
  (items: types.Expr[], ctx: string): types.Tuple;
  from(params: {
    ctx: string;
    items: types.Expr[];
    loc?: types.SourceLocation | null;
  }): types.Tuple;
}
export interface AssignBlockBuilder {
  (
    target: types.Expr,
    filter: (types.Filter | null) | undefined,
    body: types.Node[]
  ): types.AssignBlock;
  from(params: {
    body: types.Node[];
    filter?: types.Filter | null;
    loc?: types.SourceLocation | null;
    target: types.Expr;
  }): types.AssignBlock;
}
export interface ConstBuilder {
  (value: any): types.Const;
  from(params: { loc?: types.SourceLocation | null; value: any }): types.Const;
}
export interface TemplateDataBuilder {
  (data: string): types.TemplateData;
  from(params: {
    data: string;
    loc?: types.SourceLocation | null;
  }): types.TemplateData;
}
export interface ListBuilder {
  (items: types.Expr[]): types.List;
  from(params: {
    items: types.Expr[];
    loc?: types.SourceLocation | null;
  }): types.List;
}
export interface DictBuilder {
  (items: types.Pair[]): types.Dict;
  from(params: {
    items: types.Pair[];
    loc?: types.SourceLocation | null;
  }): types.Dict;
}
export interface CondExprBuilder {
  (
    test: types.Expr,
    expr1: types.Expr,
    expr2?: types.Expr | null
  ): types.CondExpr;
  from(params: {
    expr1: types.Expr;
    expr2?: types.Expr | null;
    loc?: types.SourceLocation | null;
    test: types.Expr;
  }): types.CondExpr;
}
export interface GetitemBuilder {
  (node: types.Expr, arg: types.Expr, ctx: string): types.Getitem;
  from(params: {
    arg: types.Expr;
    ctx: string;
    loc?: types.SourceLocation | null;
    node: types.Expr;
  }): types.Getitem;
}
export interface GetattrBuilder {
  (node: types.Expr, attr: string, ctx: string): types.Getattr;
  from(params: {
    attr: string;
    ctx: string;
    loc?: types.SourceLocation | null;
    node: types.Expr;
  }): types.Getattr;
}
export interface SliceBuilder {
  (
    start?: types.Expr | null,
    stop?: types.Expr | null,
    step?: types.Expr | null
  ): types.Slice;
  from(params: {
    loc?: types.SourceLocation | null;
    start?: types.Expr | null;
    step?: types.Expr | null;
    stop?: types.Expr | null;
  }): types.Slice;
}
export interface ConcatBuilder {
  (nodes: types.Expr[]): types.Concat;
  from(params: {
    loc?: types.SourceLocation | null;
    nodes: types.Expr[];
  }): types.Concat;
}
export interface CompareBuilder {
  (expr: types.Expr, ops: types.Operand[]): types.Compare;
  from(params: {
    expr: types.Expr;
    loc?: types.SourceLocation | null;
    ops: types.Operand[];
  }): types.Compare;
}
export interface OperandBuilder {
  (op: string, expr: types.Expr): types.Operand;
  from(params: {
    expr: types.Expr;
    loc?: types.SourceLocation | null;
    op: string;
  }): types.Operand;
}
export interface MulBuilder {
  (left: types.Expr, right: types.Expr): types.Mul;
  from(params: {
    left: types.Expr;
    loc?: types.SourceLocation | null;
    operator?: "*";
    right: types.Expr;
  }): types.Mul;
}
export interface DivBuilder {
  (left: types.Expr, right: types.Expr): types.Div;
  from(params: {
    left: types.Expr;
    loc?: types.SourceLocation | null;
    operator?: "/";
    right: types.Expr;
  }): types.Div;
}
export interface FloorDivBuilder {
  (left: types.Expr, right: types.Expr): types.FloorDiv;
  from(params: {
    left: types.Expr;
    loc?: types.SourceLocation | null;
    operator?: "//";
    right: types.Expr;
  }): types.FloorDiv;
}
export interface AddBuilder {
  (left: types.Expr, right: types.Expr): types.Add;
  from(params: {
    left: types.Expr;
    loc?: types.SourceLocation | null;
    operator?: "+";
    right: types.Expr;
  }): types.Add;
}
export interface SubBuilder {
  (left: types.Expr, right: types.Expr): types.Sub;
  from(params: {
    left: types.Expr;
    loc?: types.SourceLocation | null;
    operator?: "-";
    right: types.Expr;
  }): types.Sub;
}
export interface ModBuilder {
  (left: types.Expr, right: types.Expr): types.Mod;
  from(params: {
    left: types.Expr;
    loc?: types.SourceLocation | null;
    operator?: "%";
    right: types.Expr;
  }): types.Mod;
}
export interface PowBuilder {
  (left: types.Expr, right: types.Expr): types.Pow;
  from(params: {
    left: types.Expr;
    loc?: types.SourceLocation | null;
    operator?: "**";
    right: types.Expr;
  }): types.Pow;
}
export interface AndBuilder {
  (left: types.Expr, right: types.Expr): types.And;
  from(params: {
    left: types.Expr;
    loc?: types.SourceLocation | null;
    operator?: "and";
    right: types.Expr;
  }): types.And;
}
export interface OrBuilder {
  (left: types.Expr, right: types.Expr): types.Or;
  from(params: {
    left: types.Expr;
    loc?: types.SourceLocation | null;
    operator?: "or";
    right: types.Expr;
  }): types.Or;
}
export interface NotBuilder {
  (node: types.Expr): types.Not;
  from(params: {
    loc?: types.SourceLocation | null;
    node: types.Expr;
    operator?: "not";
  }): types.Not;
}
export interface NegBuilder {
  (node: types.Expr): types.Neg;
  from(params: {
    loc?: types.SourceLocation | null;
    node: types.Expr;
    operator?: "-";
  }): types.Neg;
}
export interface PosBuilder {
  (node: types.Expr): types.Pos;
  from(params: {
    loc?: types.SourceLocation | null;
    node: types.Expr;
    operator?: "+";
  }): types.Pos;
}
export interface EnvironmentAttributeBuilder {
  (name: string): types.EnvironmentAttribute;
  from(params: {
    loc?: types.SourceLocation | null;
    name: string;
  }): types.EnvironmentAttribute;
}
export interface ExtensionAttributeBuilder {
  (identifier: string, name: string): types.ExtensionAttribute;
  from(params: {
    identifier: string;
    loc?: types.SourceLocation | null;
    name: string;
  }): types.ExtensionAttribute;
}
export interface ImportedNameBuilder {
  (importname: string): types.ImportedName;
  from(params: {
    importname: string;
    loc?: types.SourceLocation | null;
  }): types.ImportedName;
}
export interface InternalNameBuilder {
  (name: string): types.InternalName;
  from(params: {
    loc?: types.SourceLocation | null;
    name: string;
  }): types.InternalName;
}
export interface MarkSafeBuilder {
  (expr: types.Expr): types.MarkSafe;
  from(params: {
    expr: types.Expr;
    loc?: types.SourceLocation | null;
  }): types.MarkSafe;
}
export interface MarkSafeIfAutoescapeBuilder {
  (expr: types.Expr): types.MarkSafeIfAutoescape;
  from(params: {
    expr: types.Expr;
    loc?: types.SourceLocation | null;
  }): types.MarkSafeIfAutoescape;
}
export interface ContextReferenceBuilder {
  (): types.ContextReference;
  from(params: { loc?: types.SourceLocation | null }): types.ContextReference;
}
export interface DerivedContextReferenceBuilder {
  (): types.DerivedContextReference;
  from(params: {
    loc?: types.SourceLocation | null;
  }): types.DerivedContextReference;
}
export interface ContinueBuilder {
  (): types.Continue;
  from(params: { loc?: types.SourceLocation | null }): types.Continue;
}
export interface BreakBuilder {
  (): types.Break;
  from(params: { loc?: types.SourceLocation | null }): types.Break;
}
export interface ScopeBuilder {
  (body: types.Node[]): types.Scope;
  from(params: {
    body: types.Node[];
    loc?: types.SourceLocation | null;
  }): types.Scope;
}
export interface OverlayScopeBuilder {
  (context: types.Expr, body: types.Node[]): types.OverlayScope;
  from(params: {
    body: types.Node[];
    context: types.Expr;
    loc?: types.SourceLocation | null;
  }): types.OverlayScope;
}
export interface EvalContextModifierBuilder {
  (options: types.Keyword[]): types.EvalContextModifier;
  from(params: {
    loc?: types.SourceLocation | null;
    options: types.Keyword[];
  }): types.EvalContextModifier;
}
export interface ScopedEvalContextModifierBuilder {
  (
    options: types.Keyword[],
    body: types.Node[]
  ): types.ScopedEvalContextModifier;
  from(params: {
    body: types.Node[];
    loc?: types.SourceLocation | null;
    options: types.Keyword[];
  }): types.ScopedEvalContextModifier;
}
export interface builders {
  template: TemplateBuilder;
  output: OutputBuilder;
  extends: ExtendsBuilder;
  for: ForBuilder;
  asyncEach: AsyncEachBuilder;
  asyncAll: AsyncAllBuilder;
  if: IfBuilder;
  name: NameBuilder;
  macro: MacroBuilder;
  keyword: KeywordBuilder;
  call: CallBuilder;
  callBlock: CallBlockBuilder;
  pair: PairBuilder;
  filter: FilterBuilder;
  test: TestBuilder;
  filterBlock: FilterBlockBuilder;
  with: WithBuilder;
  block: BlockBuilder;
  include: IncludeBuilder;
  import: ImportBuilder;
  fromImport: FromImportBuilder;
  exprStmt: ExprStmtBuilder;
  assign: AssignBuilder;
  nsRef: NSRefBuilder;
  tuple: TupleBuilder;
  assignBlock: AssignBlockBuilder;
  const: ConstBuilder;
  templateData: TemplateDataBuilder;
  list: ListBuilder;
  dict: DictBuilder;
  condExpr: CondExprBuilder;
  getitem: GetitemBuilder;
  getattr: GetattrBuilder;
  slice: SliceBuilder;
  concat: ConcatBuilder;
  compare: CompareBuilder;
  operand: OperandBuilder;
  mul: MulBuilder;
  div: DivBuilder;
  floorDiv: FloorDivBuilder;
  add: AddBuilder;
  sub: SubBuilder;
  mod: ModBuilder;
  pow: PowBuilder;
  and: AndBuilder;
  or: OrBuilder;
  not: NotBuilder;
  neg: NegBuilder;
  pos: PosBuilder;
  environmentAttribute: EnvironmentAttributeBuilder;
  extensionAttribute: ExtensionAttributeBuilder;
  importedName: ImportedNameBuilder;
  internalName: InternalNameBuilder;
  markSafe: MarkSafeBuilder;
  markSafeIfAutoescape: MarkSafeIfAutoescapeBuilder;
  contextReference: ContextReferenceBuilder;
  derivedContextReference: DerivedContextReferenceBuilder;
  continue: ContinueBuilder;
  break: BreakBuilder;
  scope: ScopeBuilder;
  overlayScope: OverlayScopeBuilder;
  evalContextModifier: EvalContextModifierBuilder;
  scopedEvalContextModifier: ScopedEvalContextModifierBuilder;
  [builderName: string]: any;
}
