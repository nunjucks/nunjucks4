// !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!!
import type * as types from "./types";
export interface TemplateBuilder {
  (body: types.Node[]): Template;
  from(params: { body: types.Node[] }): Template;
}
export interface OutputBuilder {
  (nodes: types.Expr[]): Output;
  from(params: { nodes: types.Expr[] }): Output;
}
export interface ExtendsBuilder {
  (template: types.Expr): Extends;
  from(params: { template: types.Expr }): Extends;
}
export interface ForBuilder {
  (
    target: types.Node,
    iter: types.Node,
    body: types.Node[],
    else_: types.Node[],
    test?: types.Node | null,
    recursive?: boolean
  ): For;
  from(params: {
    body: types.Node[];
    else_: types.Node[];
    iter: types.Node;
    recursive?: boolean;
    target: types.Node;
    test?: types.Node | null;
  }): For;
}
export interface IfBuilder {
  (
    test: types.Node,
    body: types.Node[],
    elif: types.If[],
    else_: types.Node[]
  ): If;
  from(params: {
    body: types.Node[];
    elif: types.If[];
    else_: types.Node[];
    test: types.Node;
  }): If;
}
export interface NameBuilder {
  (name: string, ctx: string): Name;
  from(params: { ctx: string; name: string }): Name;
}
export interface MacroBuilder {
  (
    name: string,
    args: types.Name[],
    defaults: types.Expr[],
    body: types.Node[]
  ): Macro;
  from(params: {
    args: types.Name[];
    body: types.Node[];
    defaults: types.Expr[];
    name: string;
  }): Macro;
}
export interface KeywordBuilder {
  (key: string, value: types.Expr): Keyword;
  from(params: { key: string; value: types.Expr }): Keyword;
}
export interface CallBuilder {
  (
    node: types.Expr,
    args: types.Expr[],
    kwargs: types.Keyword[],
    dynArgs?: types.Expr | null,
    dynKwargs?: types.Expr | null
  ): Call;
  from(params: {
    args: types.Expr[];
    dynArgs?: types.Expr | null;
    dynKwargs?: types.Expr | null;
    kwargs: types.Keyword[];
    node: types.Expr;
  }): Call;
}
export interface CallBlockBuilder {
  (
    call: types.Call,
    args: types.Name[],
    defaults: types.Expr[],
    body: types.Node[]
  ): CallBlock;
  from(params: {
    args: types.Name[];
    body: types.Node[];
    call: types.Call;
    defaults: types.Expr[];
  }): CallBlock;
}
export interface PairBuilder {
  (key: types.Expr, value: types.Expr): Pair;
  from(params: { key: types.Expr; value: types.Expr }): Pair;
}
export interface FilterBuilder {
  (
    node: types.Expr | null,
    name: string,
    args: types.Expr[],
    kwargs: types.Pair[],
    dynArgs?: types.Expr | null,
    dynKwargs?: types.Expr | null
  ): Filter;
  from(params: {
    args: types.Expr[];
    dynArgs?: types.Expr | null;
    dynKwargs?: types.Expr | null;
    kwargs: types.Pair[];
    name: string;
    node: types.Expr | null;
  }): Filter;
}
export interface TestBuilder {
  (
    node: types.Expr,
    name: string,
    args: types.Expr[],
    kwargs: types.Pair[],
    dynArgs?: types.Expr | null,
    dynKwargs?: types.Expr | null
  ): Test;
  from(params: {
    args: types.Expr[];
    dynArgs?: types.Expr | null;
    dynKwargs?: types.Expr | null;
    kwargs: types.Pair[];
    name: string;
    node: types.Expr;
  }): Test;
}
export interface FilterBlockBuilder {
  (body: types.Node[], filter: types.Filter): FilterBlock;
  from(params: { body: types.Node[]; filter: types.Filter }): FilterBlock;
}
export interface WithBuilder {
  (targets: types.Expr[], values: types.Expr[], body: types.Node[]): With;
  from(params: {
    body: types.Node[];
    targets: types.Expr[];
    values: types.Expr[];
  }): With;
}
export interface BlockBuilder {
  (name: string, body: types.Node[], scoped: boolean, required: boolean): Block;
  from(params: {
    body: types.Node[];
    name: string;
    required: boolean;
    scoped: boolean;
  }): Block;
}
export interface IncludeBuilder {
  (template: types.Expr, withContext: boolean, ignoreMissing: boolean): Include;
  from(params: {
    ignoreMissing: boolean;
    template: types.Expr;
    withContext: boolean;
  }): Include;
}
export interface FromImportBuilder {
  (
    template: types.Expr,
    names: (string | string[])[],
    withContext: boolean
  ): FromImport;
  from(params: {
    names: (string | string[])[];
    template: types.Expr;
    withContext: boolean;
  }): FromImport;
}
export interface ExprStmtBuilder {
  (node: types.Node): ExprStmt;
  from(params: { node: types.Node }): ExprStmt;
}
export interface AssignBuilder {
  (target: types.Expr, node: types.Node): Assign;
  from(params: { node: types.Node; target: types.Expr }): Assign;
}
export interface AssignBlockBuilder {
  (
    target: types.Expr,
    filter: (types.Filter | null) | undefined,
    body: types.Node[]
  ): AssignBlock;
  from(params: {
    body: types.Node[];
    filter?: types.Filter | null;
    target: types.Expr;
  }): AssignBlock;
}
export interface NSRefBuilder {
  (name: string, attr: string): NSRef;
  from(params: { attr: string; name: string }): NSRef;
}
export interface ConstBuilder {
  (value: any): Const;
  from(params: { value: any }): Const;
}
export interface TemplateDataBuilder {
  (data: string): TemplateData;
  from(params: { data: string }): TemplateData;
}
export interface TupleBuilder {
  (items: types.Expr[], ctx: string): Tuple;
  from(params: { ctx: string; items: types.Expr[] }): Tuple;
}
export interface ListBuilder {
  (items: types.Expr[]): List;
  from(params: { items: types.Expr[] }): List;
}
export interface DictBuilder {
  (items: types.Pair[]): Dict;
  from(params: { items: types.Pair[] }): Dict;
}
export interface CondExprBuilder {
  (test: types.Expr, expr1: types.Expr, expr2?: types.Expr | null): CondExpr;
  from(params: {
    expr1: types.Expr;
    expr2?: types.Expr | null;
    test: types.Expr;
  }): CondExpr;
}
export interface GetitemBuilder {
  (node: types.Expr, arg: types.Expr, ctx: string): Getitem;
  from(params: { arg: types.Expr; ctx: string; node: types.Expr }): Getitem;
}
export interface GetattrBuilder {
  (node: types.Expr, attr: string, ctx: string): Getattr;
  from(params: { attr: string; ctx: string; node: types.Expr }): Getattr;
}
export interface SliceBuilder {
  (
    start?: types.Expr | null,
    stop?: types.Expr | null,
    step?: types.Expr | null
  ): Slice;
  from(params: {
    start?: types.Expr | null;
    step?: types.Expr | null;
    stop?: types.Expr | null;
  }): Slice;
}
export interface ConcatBuilder {
  (nodes: types.Expr[]): Concat;
  from(params: { nodes: types.Expr[] }): Concat;
}
export interface CompareBuilder {
  (expr: types.Expr, ops: types.Operand[]): Compare;
  from(params: { expr: types.Expr; ops: types.Operand[] }): Compare;
}
export interface OperandBuilder {
  (op: string, expr: types.Expr): Operand;
  from(params: { expr: types.Expr; op: string }): Operand;
}
export interface MulBuilder {
  (left: types.Expr, right: types.Expr, operator: "*"): Mul;
  from(params: { left: types.Expr; operator: "*"; right: types.Expr }): Mul;
}
export interface DivBuilder {
  (left: types.Expr, right: types.Expr, operator: "/"): Div;
  from(params: { left: types.Expr; operator: "/"; right: types.Expr }): Div;
}
export interface FloorDivBuilder {
  (left: types.Expr, right: types.Expr, operator: "//"): FloorDiv;
  from(params: {
    left: types.Expr;
    operator: "//";
    right: types.Expr;
  }): FloorDiv;
}
export interface AddBuilder {
  (left: types.Expr, right: types.Expr, operator: "+"): Add;
  from(params: { left: types.Expr; operator: "+"; right: types.Expr }): Add;
}
export interface SubBuilder {
  (left: types.Expr, right: types.Expr, operator: "-"): Sub;
  from(params: { left: types.Expr; operator: "-"; right: types.Expr }): Sub;
}
export interface ModBuilder {
  (left: types.Expr, right: types.Expr, operator: "%"): Mod;
  from(params: { left: types.Expr; operator: "%"; right: types.Expr }): Mod;
}
export interface PowBuilder {
  (left: types.Expr, right: types.Expr, operator: "**"): Pow;
  from(params: { left: types.Expr; operator: "**"; right: types.Expr }): Pow;
}
export interface AndBuilder {
  (left: types.Expr, right: types.Expr, operator: "and"): And;
  from(params: { left: types.Expr; operator: "and"; right: types.Expr }): And;
}
export interface OrBuilder {
  (left: types.Expr, right: types.Expr, operator: "or"): Or;
  from(params: { left: types.Expr; operator: "or"; right: types.Expr }): Or;
}
export interface NotBuilder {
  (operator: "not"): Not;
  from(params: { operator: "not" }): Not;
}
export interface NegBuilder {
  (operator: "-"): Neg;
  from(params: { operator: "-" }): Neg;
}
export interface PosBuilder {
  (operator: "+"): Pos;
  from(params: { operator: "+" }): Pos;
}
export interface EnvironmentAttributeBuilder {
  (name: string): EnvironmentAttribute;
  from(params: { name: string }): EnvironmentAttribute;
}
export interface ExtensionAttributeBuilder {
  (identifier: string, name: string): ExtensionAttribute;
  from(params: { identifier: string; name: string }): ExtensionAttribute;
}
export interface ImportedNameBuilder {
  (importname: string): ImportedName;
  from(params: { importname: string }): ImportedName;
}
export interface InternalNameBuilder {
  (name: string): InternalName;
  from(params: { name: string }): InternalName;
}
export interface MarkSafeBuilder {
  (expr: types.Expr): MarkSafe;
  from(params: { expr: types.Expr }): MarkSafe;
}
export interface MarkSafeIfAutoescapeBuilder {
  (expr: types.Expr): MarkSafeIfAutoescape;
  from(params: { expr: types.Expr }): MarkSafeIfAutoescape;
}
export interface ContextReferenceBuilder {
  (): ContextReference;
  from(params: {}): ContextReference;
}
export interface DerivedContextReferenceBuilder {
  (): DerivedContextReference;
  from(params: {}): DerivedContextReference;
}
export interface ContinueBuilder {
  (): Continue;
  from(params: {}): Continue;
}
export interface BreakBuilder {
  (): Break;
  from(params: {}): Break;
}
export interface ScopeBuilder {
  (body: types.Node[]): Scope;
  from(params: { body: types.Node[] }): Scope;
}
export interface OverlayScopeBuilder {
  (context: types.Expr, body: types.Node[]): OverlayScope;
  from(params: { body: types.Node[]; context: types.Expr }): OverlayScope;
}
export interface EvalContextModifierBuilder {
  (options: types.Keyword[]): EvalContextModifier;
  from(params: { options: types.Keyword[] }): EvalContextModifier;
}
export interface ScopedEvalContextModifierBuilder {
  (options: types.Keyword[], body: types.Node[]): ScopedEvalContextModifier;
  from(params: {
    body: types.Node[];
    options: types.Keyword[];
  }): ScopedEvalContextModifier;
}
export interface builders {
  template: TemplateBuilder;
  output: OutputBuilder;
  extends: ExtendsBuilder;
  for: ForBuilder;
  if: IfBuilder;
  name: NameBuilder;
  macro: MacroBuilder;
  keyword: KeywordBuilder;
  call: CallBuilder;
  callBlock: CallBlockBuilder;
  pair: PairBuilder;
  filter: FilterBuilder;
  test: TestBuilder;
  filterBlock: FilterBlockBuilder;
  with: WithBuilder;
  block: BlockBuilder;
  include: IncludeBuilder;
  fromImport: FromImportBuilder;
  exprStmt: ExprStmtBuilder;
  assign: AssignBuilder;
  assignBlock: AssignBlockBuilder;
  nsRef: NSRefBuilder;
  const: ConstBuilder;
  templateData: TemplateDataBuilder;
  tuple: TupleBuilder;
  list: ListBuilder;
  dict: DictBuilder;
  condExpr: CondExprBuilder;
  getitem: GetitemBuilder;
  getattr: GetattrBuilder;
  slice: SliceBuilder;
  concat: ConcatBuilder;
  compare: CompareBuilder;
  operand: OperandBuilder;
  mul: MulBuilder;
  div: DivBuilder;
  floorDiv: FloorDivBuilder;
  add: AddBuilder;
  sub: SubBuilder;
  mod: ModBuilder;
  pow: PowBuilder;
  and: AndBuilder;
  or: OrBuilder;
  not: NotBuilder;
  neg: NegBuilder;
  pos: PosBuilder;
  environmentAttribute: EnvironmentAttributeBuilder;
  extensionAttribute: ExtensionAttributeBuilder;
  importedName: ImportedNameBuilder;
  internalName: InternalNameBuilder;
  markSafe: MarkSafeBuilder;
  markSafeIfAutoescape: MarkSafeIfAutoescapeBuilder;
  contextReference: ContextReferenceBuilder;
  derivedContextReference: DerivedContextReferenceBuilder;
  continue: ContinueBuilder;
  break: BreakBuilder;
  scope: ScopeBuilder;
  overlayScope: OverlayScopeBuilder;
  evalContextModifier: EvalContextModifierBuilder;
  scopedEvalContextModifier: ScopedEvalContextModifierBuilder;
  [builderName: string]: any;
}
