// !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!!
type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;
import { Type } from "../types";
export namespace types {
  export type Node =
    | Template
    | Output
    | Extends
    | For
    | If
    | Name
    | Macro
    | Keyword
    | Call
    | CallBlock
    | Pair
    | Filter
    | Test
    | FilterBlock
    | With
    | Block
    | Include
    | FromImport
    | ExprStmt
    | Assign
    | AssignBlock
    | NSRef
    | Const
    | TemplateData
    | Tuple
    | List
    | Dict
    | CondExpr
    | Getitem
    | Getattr
    | Slice
    | Concat
    | Compare
    | Operand
    | Mul
    | Div
    | FloorDiv
    | Add
    | Sub
    | Mod
    | Pow
    | And
    | Or
    | Not
    | Neg
    | Pos
    | EnvironmentAttribute
    | ExtensionAttribute
    | ImportedName
    | InternalName
    | MarkSafe
    | MarkSafeIfAutoescape
    | ContextReference
    | DerivedContextReference
    | Continue
    | Break
    | Scope
    | OverlayScope
    | EvalContextModifier
    | ScopedEvalContextModifier;
  export type Stmt =
    | Output
    | Extends
    | For
    | If
    | Macro
    | CallBlock
    | FilterBlock
    | With
    | Block
    | Include
    | FromImport
    | ExprStmt
    | Assign
    | AssignBlock
    | Continue
    | Break
    | Scope
    | OverlayScope
    | EvalContextModifier
    | ScopedEvalContextModifier;
  export type Expr =
    | Name
    | Call
    | Filter
    | Test
    | NSRef
    | Const
    | TemplateData
    | Tuple
    | List
    | Dict
    | CondExpr
    | Getitem
    | Getattr
    | Slice
    | Concat
    | Compare
    | Mul
    | Div
    | FloorDiv
    | Add
    | Sub
    | Mod
    | Pow
    | And
    | Or
    | Not
    | Neg
    | Pos
    | EnvironmentAttribute
    | ExtensionAttribute
    | ImportedName
    | InternalName
    | MarkSafe
    | MarkSafeIfAutoescape
    | ContextReference
    | DerivedContextReference;
  export type Helper = Keyword | Pair | Operand;
  export type Literal = Const | TemplateData | Tuple | List | Dict;
  export type BinExpr = Mul | Div | FloorDiv | Add | Sub | Mod | Pow | And | Or;
  export type UnaryExpr = Not | Neg | Pos;
  export interface Position {
    line: number;
    column: number;
  }
  export interface SourceLocation {
    start: Position;
    end: Position;
    source?: string | null;
  }
  export interface Printable {
    loc?: SourceLocation | null;
  }
  export interface BaseNode {
    type: string;
  }
  export interface Template extends BaseNode {
    type: "Template";
    body: Node[];
  }
  export interface Output extends BaseNode {
    type: "Output";
    nodes: Expr[];
  }
  export interface Extends extends BaseNode {
    type: "Extends";
    template: Expr;
  }
  export interface For extends BaseNode {
    type: "For";
    target: Node;
    iter: Node;
    body: Node[];
    else_: Node[];
    test?: Node | null;
    recursive?: boolean;
  }
  export interface If extends BaseNode {
    type: "If";
    test: Node;
    body: Node[];
    elif: If[];
    else_: Node[];
  }
  export interface Name extends BaseNode {
    type: "Name";
    name: string;
    ctx: string;
  }
  export interface Macro extends BaseNode {
    type: "Macro";
    name: string;
    args: Name[];
    defaults: Expr[];
    body: Node[];
  }
  export interface Keyword extends BaseNode {
    type: "Keyword";
    key: string;
    value: Expr;
  }
  export interface Call extends BaseNode {
    type: "Call";
    node: Expr;
    args: Expr[];
    kwargs: Keyword[];
    dynArgs?: Expr | null;
    dynKwargs?: Expr | null;
  }
  export interface CallBlock extends BaseNode {
    type: "CallBlock";
    call: Call;
    args: Name[];
    defaults: Expr[];
    body: Node[];
  }
  export interface Pair extends BaseNode {
    type: "Pair";
    key: Expr;
    value: Expr;
  }
  export interface FilterTestBase extends BaseNode {
    node: Expr;
    name: string;
    args: Expr[];
    kwargs: Pair[];
    dynArgs?: Expr | null;
    dynKwargs?: Expr | null;
  }
  export interface Filter extends Omit<FilterTestBase, "node"> {
    type: "Filter";
    node: Expr | null;
  }
  export interface Test extends FilterTestBase {
    type: "Test";
  }
  export interface FilterBlock extends BaseNode {
    type: "FilterBlock";
    body: Node[];
    filter: Filter;
  }
  export interface With extends BaseNode {
    type: "With";
    targets: Expr[];
    values: Expr[];
    body: Node[];
  }
  export interface Block extends BaseNode {
    type: "Block";
    name: string;
    body: Node[];
    scoped: boolean;
    required: boolean;
  }
  export interface Include extends BaseNode {
    type: "Include";
    template: Expr;
    withContext: boolean;
    ignoreMissing: boolean;
  }
  export interface FromImport extends BaseNode {
    type: "FromImport";
    template: Expr;
    names: (string | string[])[];
    withContext: boolean;
  }
  export interface ExprStmt extends BaseNode {
    type: "ExprStmt";
    node: Node;
  }
  export interface Assign extends BaseNode {
    type: "Assign";
    target: Expr;
    node: Node;
  }
  export interface AssignBlock extends BaseNode {
    type: "AssignBlock";
    target: Expr;
    filter?: Filter | null;
    body: Node[];
  }
  export interface BinExprBase extends BaseNode {
    left: Expr;
    right: Expr;
    operator: string;
  }
  export interface UnaryExprBase extends BaseNode {
    operator: string;
  }
  export interface NSRef extends BaseNode {
    type: "NSRef";
    name: string;
    attr: string;
  }
  export interface Const extends BaseNode {
    type: "Const";
    value: any;
  }
  export interface TemplateData extends BaseNode {
    type: "TemplateData";
    data: string;
  }
  export interface Tuple extends BaseNode {
    type: "Tuple";
    items: Expr[];
    ctx: string;
  }
  export interface List extends BaseNode {
    type: "List";
    items: Expr[];
  }
  export interface Dict extends BaseNode {
    type: "Dict";
    items: Pair[];
  }
  export interface CondExpr extends BaseNode {
    type: "CondExpr";
    test: Expr;
    expr1: Expr;
    expr2?: Expr | null;
  }
  export interface Getitem extends BaseNode {
    type: "Getitem";
    node: Expr;
    arg: Expr;
    ctx: string;
  }
  export interface Getattr extends BaseNode {
    type: "Getattr";
    node: Expr;
    attr: string;
    ctx: string;
  }
  export interface Slice extends BaseNode {
    type: "Slice";
    start?: Expr | null;
    stop?: Expr | null;
    step?: Expr | null;
  }
  export interface Concat extends BaseNode {
    type: "Concat";
    nodes: Expr[];
  }
  export interface Compare extends BaseNode {
    type: "Compare";
    expr: Expr;
    ops: Operand[];
  }
  export interface Operand extends BaseNode {
    type: "Operand";
    op: string;
    expr: Expr;
  }
  export interface Mul extends BinExprBase {
    type: "Mul";
    operator: "*";
  }
  export interface Div extends BinExprBase {
    type: "Div";
    operator: "/";
  }
  export interface FloorDiv extends BinExprBase {
    type: "FloorDiv";
    operator: "//";
  }
  export interface Add extends BinExprBase {
    type: "Add";
    operator: "+";
  }
  export interface Sub extends BinExprBase {
    type: "Sub";
    operator: "-";
  }
  export interface Mod extends BinExprBase {
    type: "Mod";
    operator: "%";
  }
  export interface Pow extends BinExprBase {
    type: "Pow";
    operator: "**";
  }
  export interface And extends BinExprBase {
    type: "And";
    operator: "and";
  }
  export interface Or extends BinExprBase {
    type: "Or";
    operator: "or";
  }
  export interface Not extends UnaryExprBase {
    type: "Not";
    operator: "not";
  }
  export interface Neg extends UnaryExprBase {
    type: "Neg";
    operator: "-";
  }
  export interface Pos extends UnaryExprBase {
    type: "Pos";
    operator: "+";
  }
  export interface EnvironmentAttribute extends BaseNode {
    type: "EnvironmentAttribute";
    name: string;
  }
  export interface ExtensionAttribute extends BaseNode {
    type: "ExtensionAttribute";
    identifier: string;
    name: string;
  }
  export interface ImportedName extends BaseNode {
    type: "ImportedName";
    importname: string;
  }
  export interface InternalName extends BaseNode {
    type: "InternalName";
    name: string;
  }
  export interface MarkSafe extends BaseNode {
    type: "MarkSafe";
    expr: Expr;
  }
  export interface MarkSafeIfAutoescape extends BaseNode {
    type: "MarkSafeIfAutoescape";
    expr: Expr;
  }
  export interface ContextReference extends BaseNode {
    type: "ContextReference";
  }
  export interface DerivedContextReference extends BaseNode {
    type: "DerivedContextReference";
  }
  export interface Continue extends BaseNode {
    type: "Continue";
  }
  export interface Break extends BaseNode {
    type: "Break";
  }
  export interface Scope extends BaseNode {
    type: "Scope";
    body: Node[];
  }
  export interface OverlayScope extends BaseNode {
    type: "OverlayScope";
    context: Expr;
    body: Node[];
  }
  export interface EvalContextModifier extends BaseNode {
    type: "EvalContextModifier";
    options: Keyword[];
  }
  export interface ScopedEvalContextModifier extends BaseNode {
    type: "ScopedEvalContextModifier";
    options: Keyword[];
    body: Node[];
  }
  export type ASTNode =
    | Template
    | Output
    | Extends
    | For
    | If
    | Name
    | Macro
    | Keyword
    | Call
    | CallBlock
    | Pair
    | Filter
    | Test
    | FilterBlock
    | With
    | Block
    | Include
    | FromImport
    | ExprStmt
    | Assign
    | AssignBlock
    | NSRef
    | Const
    | TemplateData
    | Tuple
    | List
    | Dict
    | CondExpr
    | Getitem
    | Getattr
    | Slice
    | Concat
    | Compare
    | Operand
    | Mul
    | Div
    | FloorDiv
    | Add
    | Sub
    | Mod
    | Pow
    | And
    | Or
    | Not
    | Neg
    | Pos
    | EnvironmentAttribute
    | ExtensionAttribute
    | ImportedName
    | InternalName
    | MarkSafe
    | MarkSafeIfAutoescape
    | ContextReference
    | DerivedContextReference
    | Continue
    | Break
    | Scope
    | OverlayScope
    | EvalContextModifier
    | ScopedEvalContextModifier;
  export let Position: Type<Position>;
  export let SourceLocation: Type<SourceLocation>;
  export let Printable: Type<Printable>;
  export let Node: Type<Node>;
  export let BaseNode: Type<BaseNode>;
  export let Stmt: Type<Stmt>;
  export let Helper: Type<Helper>;
  export let Expr: Type<Expr>;
  export let Template: Type<Template>;
  export let Output: Type<Output>;
  export let Extends: Type<Extends>;
  export let For: Type<For>;
  export let If: Type<If>;
  export let Name: Type<Name>;
  export let Macro: Type<Macro>;
  export let Keyword: Type<Keyword>;
  export let Call: Type<Call>;
  export let CallBlock: Type<CallBlock>;
  export let Pair: Type<Pair>;
  export let FilterTestBase: Type<FilterTestBase>;
  export let Filter: Type<Filter>;
  export let Test: Type<Test>;
  export let FilterBlock: Type<FilterBlock>;
  export let With: Type<With>;
  export let Block: Type<Block>;
  export let Include: Type<Include>;
  export let FromImport: Type<FromImport>;
  export let ExprStmt: Type<ExprStmt>;
  export let Assign: Type<Assign>;
  export let AssignBlock: Type<AssignBlock>;
  export let BinExpr: Type<BinExpr>;
  export let BinExprBase: Type<BinExprBase>;
  export let UnaryExpr: Type<UnaryExpr>;
  export let UnaryExprBase: Type<UnaryExprBase>;
  export let NSRef: Type<NSRef>;
  export let Literal: Type<Literal>;
  export let Const: Type<Const>;
  export let TemplateData: Type<TemplateData>;
  export let Tuple: Type<Tuple>;
  export let List: Type<List>;
  export let Dict: Type<Dict>;
  export let CondExpr: Type<CondExpr>;
  export let Getitem: Type<Getitem>;
  export let Getattr: Type<Getattr>;
  export let Slice: Type<Slice>;
  export let Concat: Type<Concat>;
  export let Compare: Type<Compare>;
  export let Operand: Type<Operand>;
  export let Mul: Type<Mul>;
  export let Div: Type<Div>;
  export let FloorDiv: Type<FloorDiv>;
  export let Add: Type<Add>;
  export let Sub: Type<Sub>;
  export let Mod: Type<Mod>;
  export let Pow: Type<Pow>;
  export let And: Type<And>;
  export let Or: Type<Or>;
  export let Not: Type<Not>;
  export let Neg: Type<Neg>;
  export let Pos: Type<Pos>;
  export let EnvironmentAttribute: Type<EnvironmentAttribute>;
  export let ExtensionAttribute: Type<ExtensionAttribute>;
  export let ImportedName: Type<ImportedName>;
  export let InternalName: Type<InternalName>;
  export let MarkSafe: Type<MarkSafe>;
  export let MarkSafeIfAutoescape: Type<MarkSafeIfAutoescape>;
  export let ContextReference: Type<ContextReference>;
  export let DerivedContextReference: Type<DerivedContextReference>;
  export let Continue: Type<Continue>;
  export let Break: Type<Break>;
  export let Scope: Type<Scope>;
  export let OverlayScope: Type<OverlayScope>;
  export let EvalContextModifier: Type<EvalContextModifier>;
  export let ScopedEvalContextModifier: Type<ScopedEvalContextModifier>;
}
export interface NunjucksTypes {
  Position: Type<types.Position>;
  SourceLocation: Type<types.SourceLocation>;
  Printable: Type<types.Printable>;
  Node: Type<types.Node>;
  BaseNode: Type<types.BaseNode>;
  Stmt: Type<types.Stmt>;
  Helper: Type<types.Helper>;
  Expr: Type<types.Expr>;
  Template: Type<types.Template>;
  Output: Type<types.Output>;
  Extends: Type<types.Extends>;
  For: Type<types.For>;
  If: Type<types.If>;
  Name: Type<types.Name>;
  Macro: Type<types.Macro>;
  Keyword: Type<types.Keyword>;
  Call: Type<types.Call>;
  CallBlock: Type<types.CallBlock>;
  Pair: Type<types.Pair>;
  FilterTestBase: Type<types.FilterTestBase>;
  Filter: Type<types.Filter>;
  Test: Type<types.Test>;
  FilterBlock: Type<types.FilterBlock>;
  With: Type<types.With>;
  Block: Type<types.Block>;
  Include: Type<types.Include>;
  FromImport: Type<types.FromImport>;
  ExprStmt: Type<types.ExprStmt>;
  Assign: Type<types.Assign>;
  AssignBlock: Type<types.AssignBlock>;
  BinExpr: Type<types.BinExpr>;
  BinExprBase: Type<types.BinExprBase>;
  UnaryExpr: Type<types.UnaryExpr>;
  UnaryExprBase: Type<types.UnaryExprBase>;
  NSRef: Type<types.NSRef>;
  Literal: Type<types.Literal>;
  Const: Type<types.Const>;
  TemplateData: Type<types.TemplateData>;
  Tuple: Type<types.Tuple>;
  List: Type<types.List>;
  Dict: Type<types.Dict>;
  CondExpr: Type<types.CondExpr>;
  Getitem: Type<types.Getitem>;
  Getattr: Type<types.Getattr>;
  Slice: Type<types.Slice>;
  Concat: Type<types.Concat>;
  Compare: Type<types.Compare>;
  Operand: Type<types.Operand>;
  Mul: Type<types.Mul>;
  Div: Type<types.Div>;
  FloorDiv: Type<types.FloorDiv>;
  Add: Type<types.Add>;
  Sub: Type<types.Sub>;
  Mod: Type<types.Mod>;
  Pow: Type<types.Pow>;
  And: Type<types.And>;
  Or: Type<types.Or>;
  Not: Type<types.Not>;
  Neg: Type<types.Neg>;
  Pos: Type<types.Pos>;
  EnvironmentAttribute: Type<types.EnvironmentAttribute>;
  ExtensionAttribute: Type<types.ExtensionAttribute>;
  ImportedName: Type<types.ImportedName>;
  InternalName: Type<types.InternalName>;
  MarkSafe: Type<types.MarkSafe>;
  MarkSafeIfAutoescape: Type<types.MarkSafeIfAutoescape>;
  ContextReference: Type<types.ContextReference>;
  DerivedContextReference: Type<types.DerivedContextReference>;
  Continue: Type<types.Continue>;
  Break: Type<types.Break>;
  Scope: Type<types.Scope>;
  OverlayScope: Type<types.OverlayScope>;
  EvalContextModifier: Type<types.EvalContextModifier>;
  ScopedEvalContextModifier: Type<types.ScopedEvalContextModifier>;
}
