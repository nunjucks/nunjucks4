// !!! THIS FILE WAS AUTO-GENERATED BY `npm run gen` !!!
import { Type } from "../types";
export type Node =
  | Orphan
  | Template
  | Output
  | Extends
  | For
  | AsyncEach
  | AsyncAll
  | If
  | Name
  | Macro
  | Keyword
  | Call
  | CallBlock
  | Pair
  | Filter
  | Test
  | FilterBlock
  | With
  | Block
  | Include
  | Import
  | FromImport
  | ExprStmt
  | Assign
  | NSRef
  | Tuple
  | AssignBlock
  | Const
  | TemplateData
  | List
  | Dict
  | CondExpr
  | Getitem
  | Getattr
  | Slice
  | Concat
  | Compare
  | Operand
  | Mul
  | Div
  | FloorDiv
  | Add
  | Sub
  | Mod
  | Pow
  | And
  | Or
  | Not
  | Neg
  | Pos
  | EnvironmentAttribute
  | ExtensionAttribute
  | ImportedName
  | InternalName
  | MarkSafe
  | MarkSafeIfAutoescape
  | ContextReference
  | DerivedContextReference
  | Continue
  | Break
  | Scope
  | OverlayScope
  | EvalContextModifier
  | ScopedEvalContextModifier;
export type Stmt =
  | Output
  | Extends
  | For
  | AsyncEach
  | AsyncAll
  | If
  | Macro
  | CallBlock
  | FilterBlock
  | With
  | Block
  | Include
  | Import
  | FromImport
  | ExprStmt
  | Assign
  | AssignBlock
  | Continue
  | Break
  | Scope
  | OverlayScope
  | EvalContextModifier
  | ScopedEvalContextModifier;
export type Loop = For | AsyncEach | AsyncAll;
export type Expr =
  | Name
  | Call
  | Filter
  | Test
  | NSRef
  | Tuple
  | Const
  | TemplateData
  | List
  | Dict
  | CondExpr
  | Getitem
  | Getattr
  | Slice
  | Concat
  | Compare
  | Mul
  | Div
  | FloorDiv
  | Add
  | Sub
  | Mod
  | Pow
  | And
  | Or
  | Not
  | Neg
  | Pos
  | EnvironmentAttribute
  | ExtensionAttribute
  | ImportedName
  | InternalName
  | MarkSafe
  | MarkSafeIfAutoescape
  | ContextReference
  | DerivedContextReference;
export type Helper = Keyword | Pair | Operand;
export type Literal = Tuple | Const | TemplateData | List | Dict;
export type BinExpr = Mul | Div | FloorDiv | Add | Sub | Mod | Pow | And | Or;
export type UnaryExpr = Not | Neg | Pos;
export interface Position {
  line: number;
  column: number;
}
export interface SourceLocation {
  start: Position;
  end?: Position | null;
  source?: string | null;
}
export interface BaseNode {
  type: string;
  loc?: SourceLocation | null;
}
export interface Orphan extends BaseNode {
  type: "Orphan";
  root: Node;
}
export interface Template extends BaseNode {
  type: "Template";
  body: Node[];
}
export interface Output extends BaseNode {
  type: "Output";
  nodes: Expr[];
}
export interface Extends extends BaseNode {
  type: "Extends";
  template: Expr;
}
export interface ForBase extends BaseNode {
  target: Node;
  iter: Node;
  body: Node[];
  else_: Node[];
  test?: Node | null;
  recursive?: boolean;
}
export interface For extends ForBase {
  type: "For";
}
export interface AsyncEach extends ForBase {
  type: "AsyncEach";
}
export interface AsyncAll extends ForBase {
  type: "AsyncAll";
}
export interface If extends BaseNode {
  type: "If";
  test: Node;
  body: Node[];
  elif: If[];
  else_: Node[];
}
export interface Name extends BaseNode {
  type: "Name";
  name: string;
  ctx: string;
}
export interface Macro extends BaseNode {
  type: "Macro";
  name: string;
  args: Name[];
  defaults: Expr[];
  body: Node[];
}
export interface Keyword extends BaseNode {
  type: "Keyword";
  key: string;
  value: Expr;
}
export interface Call extends BaseNode {
  type: "Call";
  node: Expr;
  args: Expr[];
  kwargs: Keyword[];
  dynArgs?: Expr | null;
  dynKwargs?: Expr | null;
}
export interface CallBlock extends BaseNode {
  type: "CallBlock";
  call: Call;
  args: Name[];
  defaults: Expr[];
  body: Node[];
}
export interface Pair extends BaseNode {
  type: "Pair";
  key: Expr;
  value: Expr;
}
export interface FilterTestBase extends BaseNode {
  node: Expr | null;
  name: string;
  args: Expr[];
  kwargs: Pair[];
  dynArgs?: Expr | null;
  dynKwargs?: Expr | null;
}
export interface Filter extends FilterTestBase {
  type: "Filter";
}
export interface Test extends FilterTestBase {
  type: "Test";
  node: Expr;
}
export interface FilterBlock extends BaseNode {
  type: "FilterBlock";
  body: Node[];
  filter: Filter;
}
export interface With extends BaseNode {
  type: "With";
  targets: Expr[];
  values: Expr[];
  body: Node[];
}
export interface Block extends BaseNode {
  type: "Block";
  name: string;
  body: Node[];
  scoped: boolean;
  required: boolean;
}
export interface Include extends BaseNode {
  type: "Include";
  template: Expr;
  withContext: boolean;
  ignoreMissing: boolean;
}
export interface Import extends BaseNode {
  type: "Import";
  template: Expr;
  target: string;
  withContext: boolean;
}
export interface FromImport extends BaseNode {
  type: "FromImport";
  template: Expr;
  names: (string | string[])[];
  withContext: boolean;
}
export interface ExprStmt extends BaseNode {
  type: "ExprStmt";
  node: Node;
}
export interface Assign extends BaseNode {
  type: "Assign";
  target: NSRef | Name | Tuple;
  node: Expr;
}
export interface NSRef extends BaseNode {
  type: "NSRef";
  name: string;
  attr: string;
}
export interface Tuple extends BaseNode {
  type: "Tuple";
  items: Expr[];
  ctx: string;
}
export interface AssignBlock extends BaseNode {
  type: "AssignBlock";
  target: Expr;
  filter?: Filter | null;
  body: Node[];
}
export interface BinExprBase extends BaseNode {
  left: Expr;
  right: Expr;
  operator: string;
}
export interface UnaryExprBase extends BaseNode {
  node: Expr;
  operator: string;
}
export interface Const extends BaseNode {
  type: "Const";
  value: any;
}
export interface TemplateData extends BaseNode {
  type: "TemplateData";
  data: string;
}
export interface List extends BaseNode {
  type: "List";
  items: Expr[];
}
export interface Dict extends BaseNode {
  type: "Dict";
  items: Pair[];
}
export interface CondExpr extends BaseNode {
  type: "CondExpr";
  test: Expr;
  expr1: Expr;
  expr2?: Expr | null;
}
export interface Getitem extends BaseNode {
  type: "Getitem";
  node: Expr;
  arg: Expr;
  ctx: string;
}
export interface Getattr extends BaseNode {
  type: "Getattr";
  node: Expr;
  attr: string;
  ctx: string;
}
export interface Slice extends BaseNode {
  type: "Slice";
  start?: Expr | null;
  stop?: Expr | null;
  step?: Expr | null;
}
export interface Concat extends BaseNode {
  type: "Concat";
  nodes: Expr[];
}
export interface Compare extends BaseNode {
  type: "Compare";
  expr: Expr;
  ops: Operand[];
}
export interface Operand extends BaseNode {
  type: "Operand";
  op: "eq" | "ne" | "gt" | "gteq" | "lt" | "lteq" | "in" | "notin";
  expr: Expr;
}
export interface Mul extends BinExprBase {
  type: "Mul";
  operator: "*";
}
export interface Div extends BinExprBase {
  type: "Div";
  operator: "/";
}
export interface FloorDiv extends BinExprBase {
  type: "FloorDiv";
  operator: "//";
}
export interface Add extends BinExprBase {
  type: "Add";
  operator: "+";
}
export interface Sub extends BinExprBase {
  type: "Sub";
  operator: "-";
}
export interface Mod extends BinExprBase {
  type: "Mod";
  operator: "%";
}
export interface Pow extends BinExprBase {
  type: "Pow";
  operator: "**";
}
export interface And extends BinExprBase {
  type: "And";
  operator: "and";
}
export interface Or extends BinExprBase {
  type: "Or";
  operator: "or";
}
export interface Not extends UnaryExprBase {
  type: "Not";
  operator: "not";
}
export interface Neg extends UnaryExprBase {
  type: "Neg";
  operator: "-";
}
export interface Pos extends UnaryExprBase {
  type: "Pos";
  operator: "+";
}
export interface EnvironmentAttribute extends BaseNode {
  type: "EnvironmentAttribute";
  name: string;
}
export interface ExtensionAttribute extends BaseNode {
  type: "ExtensionAttribute";
  identifier: string;
  name: string;
}
export interface ImportedName extends BaseNode {
  type: "ImportedName";
  importname: string;
}
export interface InternalName extends BaseNode {
  type: "InternalName";
  name: string;
}
export interface MarkSafe extends BaseNode {
  type: "MarkSafe";
  expr: Expr;
}
export interface MarkSafeIfAutoescape extends BaseNode {
  type: "MarkSafeIfAutoescape";
  expr: Expr;
}
export interface ContextReference extends BaseNode {
  type: "ContextReference";
}
export interface DerivedContextReference extends BaseNode {
  type: "DerivedContextReference";
}
export interface Continue extends BaseNode {
  type: "Continue";
}
export interface Break extends BaseNode {
  type: "Break";
}
export interface Scope extends BaseNode {
  type: "Scope";
  body: Node[];
}
export interface OverlayScope extends BaseNode {
  type: "OverlayScope";
  context: Expr;
  body: Node[];
}
export interface EvalContextModifier extends BaseNode {
  type: "EvalContextModifier";
  options: Keyword[];
}
export interface ScopedEvalContextModifier extends BaseNode {
  type: "ScopedEvalContextModifier";
  options: Keyword[];
  body: Node[];
}
export let Position: Type<Position>;
export let SourceLocation: Type<SourceLocation>;
export let Node: Type<Node>;
export let BaseNode: Type<BaseNode>;
export let Stmt: Type<Stmt>;
export let Helper: Type<Helper>;
export let Expr: Type<Expr>;
export let Orphan: Type<Orphan>;
export let Template: Type<Template>;
export let Output: Type<Output>;
export let Extends: Type<Extends>;
export let Loop: Type<Loop>;
export let ForBase: Type<ForBase>;
export let For: Type<For>;
export let AsyncEach: Type<AsyncEach>;
export let AsyncAll: Type<AsyncAll>;
export let If: Type<If>;
export let Name: Type<Name>;
export let Macro: Type<Macro>;
export let Keyword: Type<Keyword>;
export let Call: Type<Call>;
export let CallBlock: Type<CallBlock>;
export let Pair: Type<Pair>;
export let FilterTestBase: Type<FilterTestBase>;
export let Filter: Type<Filter>;
export let Test: Type<Test>;
export let FilterBlock: Type<FilterBlock>;
export let With: Type<With>;
export let Block: Type<Block>;
export let Include: Type<Include>;
export let Import: Type<Import>;
export let FromImport: Type<FromImport>;
export let ExprStmt: Type<ExprStmt>;
export let Assign: Type<Assign>;
export let NSRef: Type<NSRef>;
export let Literal: Type<Literal>;
export let Tuple: Type<Tuple>;
export let AssignBlock: Type<AssignBlock>;
export let BinExpr: Type<BinExpr>;
export let BinExprBase: Type<BinExprBase>;
export let UnaryExpr: Type<UnaryExpr>;
export let UnaryExprBase: Type<UnaryExprBase>;
export let Const: Type<Const>;
export let TemplateData: Type<TemplateData>;
export let List: Type<List>;
export let Dict: Type<Dict>;
export let CondExpr: Type<CondExpr>;
export let Getitem: Type<Getitem>;
export let Getattr: Type<Getattr>;
export let Slice: Type<Slice>;
export let Concat: Type<Concat>;
export let Compare: Type<Compare>;
export let Operand: Type<Operand>;
export let Mul: Type<Mul>;
export let Div: Type<Div>;
export let FloorDiv: Type<FloorDiv>;
export let Add: Type<Add>;
export let Sub: Type<Sub>;
export let Mod: Type<Mod>;
export let Pow: Type<Pow>;
export let And: Type<And>;
export let Or: Type<Or>;
export let Not: Type<Not>;
export let Neg: Type<Neg>;
export let Pos: Type<Pos>;
export let EnvironmentAttribute: Type<EnvironmentAttribute>;
export let ExtensionAttribute: Type<ExtensionAttribute>;
export let ImportedName: Type<ImportedName>;
export let InternalName: Type<InternalName>;
export let MarkSafe: Type<MarkSafe>;
export let MarkSafeIfAutoescape: Type<MarkSafeIfAutoescape>;
export let ContextReference: Type<ContextReference>;
export let DerivedContextReference: Type<DerivedContextReference>;
export let Continue: Type<Continue>;
export let Break: Type<Break>;
export let Scope: Type<Scope>;
export let OverlayScope: Type<OverlayScope>;
export let EvalContextModifier: Type<EvalContextModifier>;
export let ScopedEvalContextModifier: Type<ScopedEvalContextModifier>;
export interface NunjucksTypes {
  Position: Type<Position>;
  SourceLocation: Type<SourceLocation>;
  Node: Type<Node>;
  BaseNode: Type<BaseNode>;
  Stmt: Type<Stmt>;
  Helper: Type<Helper>;
  Expr: Type<Expr>;
  Orphan: Type<Orphan>;
  Template: Type<Template>;
  Output: Type<Output>;
  Extends: Type<Extends>;
  Loop: Type<Loop>;
  ForBase: Type<ForBase>;
  For: Type<For>;
  AsyncEach: Type<AsyncEach>;
  AsyncAll: Type<AsyncAll>;
  If: Type<If>;
  Name: Type<Name>;
  Macro: Type<Macro>;
  Keyword: Type<Keyword>;
  Call: Type<Call>;
  CallBlock: Type<CallBlock>;
  Pair: Type<Pair>;
  FilterTestBase: Type<FilterTestBase>;
  Filter: Type<Filter>;
  Test: Type<Test>;
  FilterBlock: Type<FilterBlock>;
  With: Type<With>;
  Block: Type<Block>;
  Include: Type<Include>;
  Import: Type<Import>;
  FromImport: Type<FromImport>;
  ExprStmt: Type<ExprStmt>;
  Assign: Type<Assign>;
  NSRef: Type<NSRef>;
  Literal: Type<Literal>;
  Tuple: Type<Tuple>;
  AssignBlock: Type<AssignBlock>;
  BinExpr: Type<BinExpr>;
  BinExprBase: Type<BinExprBase>;
  UnaryExpr: Type<UnaryExpr>;
  UnaryExprBase: Type<UnaryExprBase>;
  Const: Type<Const>;
  TemplateData: Type<TemplateData>;
  List: Type<List>;
  Dict: Type<Dict>;
  CondExpr: Type<CondExpr>;
  Getitem: Type<Getitem>;
  Getattr: Type<Getattr>;
  Slice: Type<Slice>;
  Concat: Type<Concat>;
  Compare: Type<Compare>;
  Operand: Type<Operand>;
  Mul: Type<Mul>;
  Div: Type<Div>;
  FloorDiv: Type<FloorDiv>;
  Add: Type<Add>;
  Sub: Type<Sub>;
  Mod: Type<Mod>;
  Pow: Type<Pow>;
  And: Type<And>;
  Or: Type<Or>;
  Not: Type<Not>;
  Neg: Type<Neg>;
  Pos: Type<Pos>;
  EnvironmentAttribute: Type<EnvironmentAttribute>;
  ExtensionAttribute: Type<ExtensionAttribute>;
  ImportedName: Type<ImportedName>;
  InternalName: Type<InternalName>;
  MarkSafe: Type<MarkSafe>;
  MarkSafeIfAutoescape: Type<MarkSafeIfAutoescape>;
  ContextReference: Type<ContextReference>;
  DerivedContextReference: Type<DerivedContextReference>;
  Continue: Type<Continue>;
  Break: Type<Break>;
  Scope: Type<Scope>;
  OverlayScope: Type<OverlayScope>;
  EvalContextModifier: Type<EvalContextModifier>;
  ScopedEvalContextModifier: Type<ScopedEvalContextModifier>;
}
